/*

1. Features of Good Relational Design.
Answer :
Features are :-
    Tabular Structure of Indexed File Data -
        * Relational databases organize data into collections of tables comprising columns and rows.
        * Micro Focus XDBC transforms COBOL data files into tables by importing Extended File Descriptor (XFD) files.
        * XFD files describe schema information associated with COBOL data files.
        * They enable XDBC to populate tables in a system catalog, mapping COBOL records to rows and columns accessible via SQL.
    System Catalog - 
        * Special utilities within Micro Focus XDBC create and populate a system catalog using information from XFDs.
        * No need for special restructuring of data files to achieve relational database-like functionality.
    SQL DDL (Data Definition Language) Support - 
        * Micro Focus XDBC supports DDL commands like CREATE and DROP.
        * Users can create and delete tables or views based on conditional operators and multiple fields/columns.
    SQL DML (Data Manipulation Language) Enhancements - 
        * Besides DDL, XDBC offers broader support for DML commands such as UNION, UNION ALL, and combined inner/outer joins.
        * Enhanced ORDER BY clause optimization improves performance.
    Multi-level Security - 
        * DDL commands GRANT and REVOKE provide data security options at database-wide and object-specific levels.
        * Different tables within the same database can have varying access levels for different users.
        * Views and object-level security allow for column-level security implementation.
    Enhanced Performance -
        * Views and object-level security allow for column-level security implementation.
Note :-
    * XDBC - XDBC (Extended Database Connectivity) is a technology by Micro Focus that transforms COBOL data files into relational database tables, enabling COBOL applications to interact with modern database systems using SQL commands.
    * XFDs - XFDs (Extended File Descriptors) are files generated by the COBOL compiler containing metadata that describes the structure and layout of COBOL data files, facilitating their integration with relational databases through technologies like XDBC.
    * COBOL - COBOL (Common Business-Oriented Language) is a programming language commonly used in business, finance, and administrative systems, known for its readability and usage in managing structured data stored in files.


2. Functional Dependencies.
Answer :
Functional dependencies (FDs) are constraints between sets of attributes in a relation. 
In simple terms, they describe the relationships between attributes in a table. 
An FD asserts that the values of certain attributes uniquely determine the values of other attributes.
Implication :-
    * Symbol : ->
    * Read as : "determines" or "functionally determines"
    * For example, if we have an FD like A → B, it means that knowing the value of attribute A uniquely determines the value of attribute B. In other words, the value of B is functionally dependent on the value of A.
Types of Functional Dependencies :-
    Trivial - 
        * An FD is trivial if the right-hand side (RHS) of the dependency is a subset of the left-hand side (LHS). 
        * Dependency where one attribute determines itself.
        * Mathematical Ex - If A → A, it is a trivial FD.
        * Practical Ex - In a table of employees, where each employee has an Employee ID, the Employee ID determining itself is a trivial dependency.
    Non-Trivial - 
        * An FD is non-trivial if the RHS is not a subset of the LHS. 
        * Dependency where one attribute determines another attribute.
        * Mathematical Ex - If A → B, where B is not a subset of A, it is a non-trivial FD.
        * Practical Ex - In a table of students, the Grade attribute might be determined by the Exam Score attribute.
    Fully Functional -
        * In a fully functional FD, the RHS is fully determined by the entire set of attributes in the LHS. 
        * Dependency where no subset of attributes can determine the remaining attributes.
        * Mathematical Ex - If {OrderID, ProductID} → Price, where knowing both OrderID and ProductID determines the Price uniquely.
        * Practical Ex - In a table of customers, both the Customer ID and Name together uniquely determine the Address.
    Partial - 
        * In a partial FD, the RHS is determined by only a part of the attributes in the LHS. 
        * Dependency where some attributes determine others but not all.
        * Mathematical Ex - If {OrderID, ProductID} → Price, where knowing only OrderID partially determines the Price.
        * Practical Ex - In a table of orders, the Order Total might be determined by both the Product Price and Quantity, but not by the Order Date.
    Transitive - 
        * A transitive FD occurs when A → B and B → C imply A → C.
        * Dependency where one attribute indirectly determines another through a chain of dependencies.
        * Mathematical Ex - if CustomerID → OrderID and OrderID → TotalAmount, then CustomerID → TotalAmount.
        * Practical Ex - In a table of courses, if the Course Instructor determines the Department, and the Department determines the Location, then the Course Instructor indirectly determines the Location through a chain of dependencies.
    Multi-Valued - 
        * Multi-valued FDs arise when the presence of one attribute value implies the presence of another attribute value in a different table. 
        * They are common in relational databases with multiple tables.
        * Multivalued dependency occurs when a set of attributes determines the existence of certain sets of values in a relation.
        * Ex - In a table of employees, if Employee ID determines both the Project Assigned and the Skills, but the Project Assigned and Skills are independent of each other, then there is a multivalued dependency between Project Assigned and Skills with respect to Employee ID.
Key Terms :-
    Axiom - In the context of FDs, axioms are fundamental principles or rules that guide the behavior of functional dependencies.
    Decomposition - Decomposition involves breaking a relation into smaller relations to eliminate redundancy and improve data integrity.
    Dependent - A dependent attribute is one whose value is determined by another attribute or set of attributes.
    Determinant - A determinant is an attribute or set of attributes on the LHS of an FD that determines the value of another attribute on the RHS.
    Union - The union of two sets of attributes in an FD refers to combining them into a single set.
Rules of Functional Dependencies :-
    Reflexive rule - 
        * The reflexive rule states that if Y is a subset of X, then X → Y holds. 
        * For example, if {OrderID, ProductID} → {OrderID}, it is a valid FD.
    Augmentation rule - 
        * The augmentation rule states that if X → Y holds, then XZ → YZ also holds. 
        * For example, if OrderID → TotalAmount, then OrderID, CustomerID → TotalAmount, CustomerID also holds.
    Transitivity rule - 
        * The transitivity rule states that if X → Y and Y → Z hold, then X → Z also holds. 
        * For example, if OrderID → CustomerID and CustomerID → TotalAmount, then OrderID → TotalAmount.


3. Normalisation.
Answer :
Process of organizing data in a database to minimize redundancy and dependency by organizing tables into smaller entities and defining relationships between them.
Two types of Redundancy :-
    Row Level -----> Can be Solved Using Constraints
    Column Level(IMP) -----> Can be Solved Using Normalisation
Normalization rules divides larger tables into smaller tables and links them using relationships.


4. Purpose of Normalisation.
Answer :
Purpose of Normalisation in SQL - 
    * To eliminate redundant (repetitive) data and ensure data is stored logically.
    * Eliminate redundancy.
    * Prevent anomalies.
    * Ensure data integrity.
    * Prevent the Same Data from Being Stored in Many Places.
    * Prevent Updates Made to Some Data and Not Others.
    * Prevent Deleting Unrelated Data.
    * Ensure Queries are More Efficient.


5. Three Anomalies resolved by Normalisation.
Answer :
Anomalies - Issues that can occur in a database due to redundancy and inconsistent data.
    Insertion Anomaly : 
        * Problems that arise when we try to insert data into a table.
        * Ex - Imagine a table that stores information about students and their courses.
        StudentID	StudentName	CourseID	CourseName
        1	        Alice	    C1	        Database
        2	        Bob	        C2	        Networking
        * Problem - If we want to insert a new course that no student is enrolled in yet, we cannot do so without inserting a student. For example, inserting a new course "Web Development" requires a dummy student entry.
    Deletion Anomaly : 
        * Problems that arise when we try to delete data from a table.
        * Ex - Imagine a table that stores information about students and their courses.
        StudentID	StudentName	CourseID	CourseName
        1	        Alice	    C1	        Database
        2	        Bob	        C2	        Networking
        * Problem - If we delete the student "Alice," we also lose the information about the course "Database." This happens because the course information is tied to the student information.
    Update Anomaly : 
        * Problems that arise when we try to update data in a table.
        * Ex - Imagine a table that stores information about students and their courses.
        StudentID	StudentName	CourseID	CourseName
        1	        Alice	    C1	        Database
        2	        Bob	        C2	        Networking
        * Problem - If the course name "Database" changes to "Advanced Database," we need to update all entries where the course is listed. If we forget to update any row, it leads to inconsistent data.


6. Types of Normalisation.
Answer :
There are 7 types of Normalisation :-
    1NF (First Normal Form)
    2NF (Second Normal Form)
    3NF (Third Normal Form)
    BCNF (Boyce-Codd Normal Form)
    4NF (Fourth Normal Form)
    5NF (Fifth Normal Form)
    6NF (Sixth Normal Form)
Note - Theory of Data Normalization in MySQL server is still being developed further. For example, there are discussions even on 6th Normal Form. However, in most practical applications, normalization achieves its best in 3rd Normal Form. 


7. 1NF(1st Normal Form).
Answer :
Rules :-
    * Ensure that each column has atomic values.
    * Ensure that each column contains values of a single type.
    * Ensure that there are no repeating groups or arrays in any column.
Note :-
    * In a 1NF relation the order of the tuples (rows) and attributes (columns) does not matter.
    * The first requirement above means that the relation must have a key. 
    * The key may be single attribute or composite key. It may even, possibly, contain all the columns.
    * The first normal form defines only the basic structure of the relation and does not resolve the anomalies discussed.
Purpose :-
    * Eliminate repeating groups within a table.
Steps :- 
    * Splitting tables and ensuring each attribute contains atomic values.
Example :-
    * Consider a table with student and course information:
    StudentID	StudentName	    Courses
    1	        Alice	        Database, Networking
    2	        Bob	            Database
    * This table is not in 1NF because the "Courses" column contains multiple values
    Achieving 1NF -
    * Separate the courses into different rows.
        StudentID	StudentName	    Course
        1	        Alice	        Database
        1	        Alice	        Networking
        2	        Bob	            Database


8. 2NF(2nd Normal Form).
Answer :
Rules :-
    * Be in 1NF.
    * All non-key attributes are fully functional dependent on the primary key.
Purpose :- 
    * Eliminate partial dependencies.
Steps :- 
    * Ensuring each non-key attribute is fully functionally dependent on the primary key.
    * Remove partial dependencies, ensure that non-key attributes depend on the whole primary key.
Example :-
    * Consider a table with student and course information.
    StudentID	CourseID	StudentName	    CourseName
    1	        C1	        Alice	        Database
    1	        C2	        Alice	        Networking
    2	        C1	        Bob 	        Database
    * This table is in 1NF but not in 2NF because "StudentName" depends only on "StudentID" and "CourseName" depends only on "CourseID".
    Achieving 2NF - 
    * Separate the data into different tables.
    Students Table
        StudentID	StudentName
        1	        Alice
        2	        Bob
    Courses Table
        CourseID	CourseName
        C1	        Database
        C2	        Networking
    Enrollments Table
        StudentID	CourseID
        1	        C1
        1	        C2
        2	        C1


9. 3NF(3rd Normal Form).
Answer :
Rules :-   
    * Be in 2NF.
    * All non-key attributes are non-transitively dependent on the primary key (i.e. there are no transitive dependencies).
    * Ek table tab 3NF mein hoti hai jab woh 2NF mein hoti hai aur koi bhi non-key attribute transitive dependency na dikhata ho. Matlab, non-key attributes directly primary key pe depend karein, na ki kisi aur non-key attribute pe.
Purpose :- 
    * Eliminate transitive dependencies.
Steps :- 
    * Remove transitive dependencies; ensure that non-key attributes depend only on the primary key.
Example :-
    * Consider a table with student, course, and instructor information.
    StudentID	CourseID	CourseName	InstructorID	InstructorName
    1	        C1	        Database	I1	            Dr. Smith
    1	        C2	        Networking	I2	            Dr. Jones
    2	        C1	        Database	I1	            Dr. Smith
    * This table is in 2NF but not in 3NF because "InstructorName" depends on "InstructorID".
    Achieving 3NF -
    * Separate the data into different tables.
    Students Table
        StudentID	StudentName
        1	        Alice
        2	        Bob
    Courses Table
        CourseID	CourseName	InstructorID
        C1	        Database	I1
        C2	        Networking	I2
    Instructors Table
        InstructorID	InstructorName
        I1	            Dr. Smith
        I2	            Dr. Jones
    Enrollments Table
        StudentID	CourseID
        1	        C1
        1	        C2
        2	        C1


10. BCNF(Boyce-Codd Normal Form).
Answer :
Rules :-   
    * Be in 3NF.
    * For every functional dependency X→Y, X should be a super key.
Even when a database is in 3rd Normal Form, still there would be anomalies resulted if it has more than one Candidate Key.
Sometimes is BCNF is also referred as 3.5 Normal Form.
Purpose :- 
    * Further normalization to eliminate anomalies related to non-trivial functional dependencies.
Steps :- 
    * Ensure that for every functional dependency X→Y, X is a super key.
Example - 
    * Consider a table with student, course, and instructor information:.
    StudentID	CourseID	InstructorID
    1	        C1	        I1
    1	        C2	        I2
    2	        C1	        I1
    * Assume that a course is taught by a single instructor, but an instructor can teach multiple courses. This table is in 3NF but may not be in BCNF because "InstructorID" depends on "CourseID" but "CourseID" is not a super key.
    Achieving BCNF - 
    * Separate the data into different tables.
    Courses Table
        CourseID	InstructorID
        C1	        I1
        C2	        I2
    Enrollments Table
        StudentID	CourseID
        1	        C1
        1	        C2
        2	        C1

*/ 